package in.gov.lrit.asp.dnid;

/*import java.io.StringWriter;*/
import java.math.BigInteger;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

/*import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;*/
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.imo.gisis.xml.lrit._2008.Response;
import org.imo.gisis.xml.lrit._2008.ResponseType;

import org.imo.gisis.xml.lrit.dnidrequest._2008.DNIDRequestType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import in.gov.lrit.asp.common.DBUpdation;

public class AspDINDRequest implements Processor {

	///////////////// THIS CLASS RECEIVES PACKET FROM PORTAL //////////////////////

	// DataSource dataSource;
	DBUpdation dbProcess;

	public DBUpdation getDbProcess() {
		return dbProcess;
	}

	public void setDbProcess(DBUpdation dbProcess) {
		this.dbProcess = dbProcess;
	}

	DNIDRequestType dnidRequest;
	Logger log = (Logger) LoggerFactory.getLogger(AspDINDRequest.class);

	@Override
	public void process(Exchange exchange) throws Exception {
		Response resp = new Response();

		System.out.println("INSIDE ASPDNIDREQUEST CLASS");

		// Step1: log the Request
		this.dnidRequest = exchange.getIn().getBody(DNIDRequestType.class);
		log.info("[" + dnidRequest.getMessageId() + "] DNID Request Received. ");

		String message_id = dnidRequest.getMessageId();
		BigInteger requestType = dnidRequest.getRequestType();
		// String dnidNo = dnidRequest.getDNIDNo();
		String imoNo = dnidRequest.getIMONum();
		int memberNo = dnidRequest.getMemberNo();
		BigInteger messageType = dnidRequest.getMessageType();
		XMLGregorianCalendar timeStamp = dnidRequest.getTimeStamp();
		BigInteger oceanRegion = dnidRequest.getOceanRegion();
		Timestamp currentTimestamp = new Timestamp(Calendar.getInstance().getTime().getTime());
		log.info("timestamp: " + currentTimestamp);

		boolean validationStatus = (boolean) exchange.getIn().getHeader("validationStatus");
		// Step3: Update Transaction DB
		// get Ship Borne Equipment Id for address code in poll command
		dbProcess.getShipInfo(imoNo);
		String[] data = new String[3];
		data = dbProcess.getShipInfo(imoNo);
		String shipBorneEquipmentId = data[1].trim();
		String dnidNo = data[2].trim();
		log.info("shipid and dnidno is == " + shipBorneEquipmentId + "  " + dnidNo);

		// BigInteger message_type= BigInteger.valueOf(18);

		dbProcess.setDnidInactive(imoNo);
		boolean updateDb = dbProcess.insertAspDninDB(message_id, dnidNo, memberNo, currentTimestamp, oceanRegion,
				imoNo);
		log.info("dbupdatetion successfull" + updateDb);

		//////////////////////////ADDED SYNC CALCULATION //////////////////// 
		int requestTypeInt = requestType.intValue();

		if (requestTypeInt == 51) {
			String lrit_id = dbProcess.getCgOwnerFromIMONO(imoNo);
			int delay = dbProcess.getDelay(imoNo);
			dbProcess.terminateallRequest(imoNo);
			Instant instant = getSynctime(timeStampToXMLGregorianCalender(dbProcess.getCurrentTimestamp()), 360, delay);
			Timestamp next = Timestamp.from(instant);
			log.info("next timestamp is" + next);

			dbProcess.insertTerminalfrequency(message_id, dbProcess.getimo_num(memberNo, Integer.valueOf(dnidNo)),
					dnidNo, memberNo, lrit_id, 360, timeStampToXMLGregorianCalender(next), "INACTIVE");
		}

		// Step3 a: Fail return error to portal
		if (updateDb == false || shipBorneEquipmentId == "")
			validationStatus = false;

		if (validationStatus == false) {
			resp.setResponse(ResponseType.SUCCESS);
			exchange.getOut().setBody(resp);
		}
		// Step3 b: Success return ack to portal
		else {
			resp.setResponse(ResponseType.SUCCESS);
			// Step4: log the DNID request details
			log.info("[" + message_id + "] DNID request details are: ");
			log.info("[MessageId: " + dnidRequest.getMessageId() + "");
			log.info("requestType: " + requestType + "");
			log.info("dnidNo: " + dnidNo + "");
			log.info("imoNo: " + imoNo + "");
			log.info("memberNo: " + memberNo + "");
			log.info("timeStamp: " + timeStamp + "");
			log.info("oceanRegion: " + oceanRegion + "");

			exchange.getOut().setHeader("imo_no", imoNo);
			exchange.getOut().setHeader("message_id", message_id);
			exchange.getOut().setHeader("memberNo", memberNo);
			exchange.getOut().setHeader("requestType", requestType);
			exchange.getOut().setHeader("accessType", requestType);
			exchange.getOut().setHeader("dnidNo", dnidNo);
			exchange.getOut().setHeader("shipBorneEquipmentId", shipBorneEquipmentId);
			exchange.getOut().setHeader("validationStatus", validationStatus);
			exchange.getOut().setHeader("MessageType", messageType);

			exchange.getOut().setBody(resp);
		}

	}

	public XMLGregorianCalendar timeStampToXMLGregorianCalender(Timestamp ldt) {
		try {
			log.info("Current Time to convert : " + ldt.getTime());
			// DateFormat df = new SimpleDateFormat("YYYY-MM-dd'T'HH:mm:ss.sssX");
			DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
			df.setTimeZone(TimeZone.getTimeZone("UTC"));
			String date = df.format(ldt);
			log.debug("date : " + date);
			XMLGregorianCalendar XGC = DatatypeFactory.newInstance().newXMLGregorianCalendar(date);
			log.debug("Current Time after convertion df format : " + XGC.toGregorianCalendar().getTime());
			return XGC;
		} catch (DatatypeConfigurationException e) {
			e.printStackTrace();
			return null;
		}
	}

	public Instant getSynctime(XMLGregorianCalendar start_time, int frequencyRate, int delay) {

		log.info("Inside Synchronise Method");
		int Basetime = 1440; // 24hrs
		int A = Basetime - frequencyRate;

		Date start_date = start_time.toGregorianCalendar().getTime();

		Date current_date = new Date();

		log.info("Start Date : " + start_date);
		log.info("Current Date : " + current_date);

		Calendar calendar = Calendar.getInstance();
		if (start_date.compareTo(current_date) <= 0) {
			log.info("Start Time is already lapsed, so set to current time");
			calendar.setTime(current_date);
		} else {
			log.info("Start Time is in future, so set to the start time");
			calendar.setTime(start_date);
		}

		int hours = calendar.get(Calendar.HOUR_OF_DAY);
		int minutes = calendar.get(Calendar.MINUTE);

		log.info("Start Time :  Hour : Miniute :  " + hours + ": " + minutes);

		int initialReqTimeMinutes = (hours * 60) + minutes;
		int syncTime = 0;

		log.info("Request Time in minutes : " + initialReqTimeMinutes);
		log.info("A : " + A);
		int B = A - initialReqTimeMinutes;
		log.info("B : " + B);
		if (B > frequencyRate) {
			while (B > frequencyRate) {
				Basetime = A;
				log.debug("Modified BaseTime :  " + Basetime);
				A = Basetime - frequencyRate;
				log.debug("Modified A : " + A);
				B = A - initialReqTimeMinutes;
				log.debug("Modified B : " + B);
			}
		}
		syncTime = A;
		log.info("Calculated SYNC Start Time : " + syncTime);

		syncTime = syncTime + delay;
		log.info("Calculated SYNC Start Time + Delay : " + syncTime);

		if ((syncTime - initialReqTimeMinutes) > frequencyRate + 30) {
			log.info("Difference between sync time & request start time was greater than frequency time + 30 ");
			syncTime = syncTime - frequencyRate;
			log.info("Hence substracting frequencyrate , Now Sync Time : " + syncTime);
		}

		if ((syncTime - initialReqTimeMinutes) < 15) {
			log.info("Difference between sync time & request start time was less than 15 minutes ");
			syncTime = syncTime + frequencyRate;
			log.info("Hence adding frequencyrate , Now Sync Time : " + syncTime);
		}

		while (((syncTime - frequencyRate) - initialReqTimeMinutes) > 15) {
			log.info("Difference between sync time & request time greater than 15, subtract frequency rate");
			syncTime = syncTime - frequencyRate;
		}

		hours = syncTime / 60;
		minutes = syncTime % 60;

		log.info("SYNC Start Time :: Hours:Minutes " + hours + ":" + minutes);
		Calendar newcalendar = Calendar.getInstance();
		newcalendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR));
		newcalendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH));
		newcalendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH));
		newcalendar.set(Calendar.HOUR_OF_DAY, hours);
		newcalendar.set(Calendar.MINUTE, minutes);
		newcalendar.set(Calendar.SECOND, 00);
		newcalendar.set(Calendar.MILLISECOND, 00);
		Date d = newcalendar.getTime();

		Instant instant = d.toInstant();
		log.info("Date : " + d.toString());
		log.info("Instant :" + instant);
		return instant;

	}

}
